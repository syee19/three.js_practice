<!DOCTYPE html>
<html>
  <head>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>Three.js Snowball</title>
    <meta charset="utf-8" />
    <style>
      body {
        margin: 0;
        height: 100%;
        background-size: cover;
        overflow: hidden;
        touch-action: none;
      }
      #info {
        color: aliceblue;
        z-index: 1;
      }
      ul {
        list-style: none;
        padding: 10px;
      }
      .btn {
        margin: 20px;
        position: relative;
        border: none;
        display: inline-block;
        padding: 12px 18px;
        border-radius: 15px;
        text-decoration: none;
        font-weight: 600;
        transition: 0.25s;
        background-color: #5b8d80;
        color: #f0f8ff;
      }
      .container {
        height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: #171717;
      }
      .inner {
        height: auto;
        flex-direction: row;
      }
      #c {
        margin-bottom: 0;
        width: 90vw;
        height: auto;
      }
      @media (min-width: 752px) {
        #c {
          margin-bottom: 0;
          width: 600px;
          height: 600px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <canvas id="c"></canvas>
      <div id="info">
        <div class="container inner">
          <a id="start_demo" class="btn" href="#" role="button">Start</a>
          <ul>
            <li>
              X-axis: <span id="Accelerometer_gx">0.0</span
              ><span> m/s<sup>2</sup></span>
            </li>
            <li>
              Y-axis: <span id="Accelerometer_gy">0.0</span
              ><span> m/s<sup>2</sup></span>
            </li>
            <li>
              Z-axis: <span id="Accelerometer_gz">0.0</span
              ><span> m/s<sup>2</sup></span>
            </li>
          </ul>
        </div>
      </div>
    </div>
    <script type="module">
      import * as THREE from "https://threejsfundamentals.org/threejs/resources/threejs/r125/build/three.module.js";

      let basisDir = 1;

      function main() {
        const canvas = document.querySelector("#c");
        const renderer = new THREE.WebGLRenderer({
          canvas,
          antialias: true,
          alpha: true,
        });

        const fov = 70;
        const aspect = 1;
        const near = 0.1;
        const far = 10;
        const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.position.z = 4.5;

        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x171717, 1, 6.5);
        //scene.background = new THREE.Color(0x171717);

        const geometry = new THREE.SphereGeometry(2.5, 32, 16);
        const material = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.05,
        });
        const snowBall = new THREE.Mesh(geometry, material);
        scene.add(snowBall);

        //* mesh 생성 함수
        function addShape(x, y, z) {
          //star shape (*)
          const shape = new THREE.Shape()
            .moveTo(3, 5)
            .lineTo(3, 21)
            .lineTo(-3, 21)
            .lineTo(-3, 5)
            .lineTo(-17, 13)
            .lineTo(-20, 8)
            .lineTo(-6, 0)
            .lineTo(-20, -8)
            .lineTo(-17, -13)
            .lineTo(-3, -5)
            .lineTo(-3, -21)
            .lineTo(3, -21)
            .lineTo(3, -5)
            .lineTo(17, -13)
            .lineTo(20, -8)
            .lineTo(6, 0)
            .lineTo(20, 8)
            .lineTo(17, 13)
            .lineTo(3, 5); // close path

          //scale 조정
          var s = 0.005;
          let geometry = new THREE.ShapeGeometry(shape);

          let mesh = new THREE.Mesh(
            geometry,
            new THREE.MeshBasicMaterial({
              color: 0xf0f8ff, //0x5b8d80,
              side: THREE.DoubleSide,
            })
          );
          mesh.position.set(x, y, z);
          mesh.scale.set(s, s, s);
          scene.add(mesh);
          return mesh;
        }

        //원점 주변에 일정 간격으로 랜덤하게 * mesh 생성
        var arr = [];
        var velo = [];
        var n = 50;
        const seta = (Math.PI * 2) / n;
        var len, shx, shy, shz;
        for (var i = 0; i < n; i++) {
          len = Math.random() * 0.4 + 0.6;
          shx = len * Math.sin(i * seta);
          shy = len * Math.cos(i * seta);
          shz = Math.sqrt(1 - shx * shx - shy * shy);
          len = Math.random() * 2.3;
          arr.push(addShape(len * shx, len * shy, len * shz));
          //arr.push(addShape(0, 0, 0));
          velo.push(0.002 + Math.random() / 90);
        }

        //중력 방향 arrowHelper
        const dir = new THREE.Vector3(0, -1, 0);
        const origin = new THREE.Vector3(0, 0, 0);
        const length = 2;
        const hex = 0xffffff;
        const arrowHelper = new THREE.ArrowHelper(
          dir,
          origin,
          length,
          hex,
          0.4
        );
        scene.add(arrowHelper);

        var gx;
        var gy;
        var gz;

        // render 혹은 animate loop를 불러 렌더링하기
        function render(time) {
          if (resizeRendererToDisplaySize(renderer)) {
            camera.updateProjectionMatrix();
          }

          gx = basisDir * document.getElementById("Accelerometer_gx").innerHTML;
          gy = basisDir * document.getElementById("Accelerometer_gy").innerHTML;
          gz = basisDir * document.getElementById("Accelerometer_gz").innerHTML;
          dir.set(gx, gy, gz);
          dir.normalize();

          if (dir.length() == 0) {
            dir.set(0, -1, 0);
          }

          arrowHelper.setDirection(dir);
          //arrowHelper.setLength(dir.length());

          //* 애니메이션
          for (var i = 0; i < arr.length; i++) {
            //if (arr[i].position.y <= -2.5) arr[i].position.y = 2.5;
            /* 구 범위를 벗어나면 점대칭이동
            arr[i].position.x += velo[i] * dir.x;
            arr[i].position.y += velo[i] * dir.y;
            arr[i].position.z += velo[i] * dir.z;
            if (getDistance(arr[i]) >= 2.3) {
              arr[i].position.x *= -1;
              arr[i].position.y *= -1;
              arr[i].position.z *= -1;
            }
            */
            if (getDistance(arr[i]) >= 2.35) {
              var sdir = slideDirection(arr[i], dir);
              arr[i].position.x += sdir.x;
              arr[i].position.y += sdir.y;
              arr[i].position.z += sdir.z;
            } else {
              arr[i].position.x += velo[i] * dir.x;
              arr[i].position.y += velo[i] * dir.y;
              arr[i].position.z += velo[i] * dir.z;
              if (getDistance(arr[i]) >= 2.5) {
                arr[i].position.normalize();
                arr[i].position.multiplyScalar(2.35);
              }
            }
            arr[i].lookAt(camera.position);
          }

          renderer.render(scene, camera);
          requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
      }

      main();

      function slideDirection(arr, dir) {
        var pjdir = dir.clone();
        var res = new THREE.Vector3();
        res.subVectors(dir, pjdir.projectOnVector(arr.position));
        res = res.multiplyScalar(
          Math.pow(Math.sin(dir.angleTo(arr.position)) * 0.8, 15)
        );
        return res;
      }
      console.log(Math.sin(1.57));

      function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement;
        const width = canvas.clientWidth;
        const height = canvas.clientWidth;
        const needResize = canvas.width !== width || canvas.height !== height;
        if (needResize) {
          renderer.setSize(width, height, false);
        }
        return needResize;
      }

      function getDistance(point) {
        var x2 = point.position.x * point.position.x;
        var y2 = point.position.y * point.position.y;
        var z2 = point.position.z * point.position.z;
        //dist = Math.cqrt(x2 + y2 + z2);
        var dist = Math.sqrt(x2 + y2 + z2);
        return dist;
      }

      //Orientation
      function handleMotion(event) {
        updateFieldIfNotNull(
          "Accelerometer_gx",
          event.accelerationIncludingGravity.x - event.acceleration.x
        );
        updateFieldIfNotNull(
          "Accelerometer_gy",
          event.accelerationIncludingGravity.y - event.acceleration.y
        );
        updateFieldIfNotNull(
          "Accelerometer_gz",
          event.accelerationIncludingGravity.z - event.acceleration.z
        );
      }

      function updateFieldIfNotNull(fieldName, value, precision = 1) {
        if (value != null)
          document.getElementById(fieldName).innerHTML =
            value.toFixed(precision);
      }

      let is_running = false;

      let demo_button = document.getElementById("start_demo");
      demo_button.onclick = function (e) {
        e.preventDefault();
        // Request permission for iOS 13+ devices
        if (typeof DeviceMotionEvent.requestPermission === "function") {
          DeviceMotionEvent.requestPermission()
            .then((state) => {
              if (state === "granted") {
                //window.alert("granted!");
                basisDir = 1;
              } else {
                //window.alert("denied!");
              }
            })
            .catch(console.error);
        } else {
          basisDir = -1;
          // Handle regular non iOS 13+ devices.
        }

        if (is_running) {
          window.removeEventListener("devicemotion", handleMotion);
          demo_button.innerHTML = "Start";
          updateFieldIfNotNull("Accelerometer_gx", 0.0);
          updateFieldIfNotNull("Accelerometer_gy", 0.0);
          updateFieldIfNotNull("Accelerometer_gz", 0.0);
          is_running = false;
        } else {
          window.addEventListener("devicemotion", handleMotion);
          demo_button.innerHTML = "Stop";
          is_running = true;
        }
      };
    </script>
  </body>
</html>
